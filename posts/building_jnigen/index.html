<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>Building jnigen - A Java bindings generator for Dart</title>
<meta name=description content><meta name=keywords content='Dart,Flutter,Java,Developer Tools'><meta property="og:url" content="https://mahesh-hegde.github.io/posts/building_jnigen/"><meta property="og:type" content="website"><meta property="og:title" content="Building jnigen - A Java bindings generator for Dart"><meta property="og:description" content><meta property="og:image" content="https://mahesh-hegde.github.io/"><meta property="og:image:secure_url" content="https://mahesh-hegde.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Building jnigen - A Java bindings generator for Dart"><meta name=twitter:description content><meta property="twitter:domain" content="https://mahesh-hegde.github.io/posts/building_jnigen/"><meta property="twitter:url" content="https://mahesh-hegde.github.io/posts/building_jnigen/"><meta name=twitter:image content="https://mahesh-hegde.github.io/"><link rel=canonical href=https://mahesh-hegde.github.io/posts/building_jnigen/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fbe2f55794ed6ded1573152a130784ee5cb022de9676b19dd37d7559ee6f6fc6.js integrity="sha256-++L1V5Ttbe0VcxUqEweE7lywIt6WdrGd0311We5vb8Y="></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=nav-title><a class=nav-brand href=https://mahesh-hegde.github.io/>Loop Invariant</a></div><div class=nav-links><div class=nav-link><a href=https://mahesh-hegde.github.io/posts/><span data-feather=book-open></span> Posts</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/tags/><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/cv/><span data-feather=briefcase></span> CV</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/readings/><span data-feather=book></span> Readings</a></div><div class=nav-link><a href=mailto:net.mahesh29@gmail.com><span data-feather=mail></span></a></div><div class=nav-link><a href=https://github.com/mahesh-hegde><span data-feather=github></span></a></div><div class=nav-link><a href=https://www.linkedin.com/in/mahesh-bhaskar-hegde/><span data-feather=linkedin></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span id=dark-theme-toggle-screen-reader-target class=sr-only></span>
<a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span id=hamburger-menu-toggle-screen-reader-target class=sr-only>menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://mahesh-hegde.github.io/posts/><span data-feather=book-open></span> Posts</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/cv/><span data-feather=briefcase></span> CV</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/readings/><span data-feather=book></span> Readings</a></li><li class=nav-item><a href=mailto:net.mahesh29@gmail.com><span data-feather=mail></span></a></li><li class=nav-item><a href=https://github.com/mahesh-hegde><span data-feather=github></span></a></li><li class=nav-item><a href=https://www.linkedin.com/in/mahesh-bhaskar-hegde/><span data-feather=linkedin></span></a></li><li class="nav-item dark-theme-toggle"><span id=dark-theme-toggle-screen-reader-target class=sr-only>theme</span>
<a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Building jnigen - A Java bindings generator for Dart</h1><small role=doc-subtitle></small><p class=post-date>July 19, 2023</p><ul class=post-tags><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/dart>Dart</a></li><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/flutter>Flutter</a></li><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/java>Java</a></li><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/developer-tools>Developer Tools</a></li></ul></div><div class=post-content><p><blockquote><blockquote><p>Caine: Then why bother?</p><p>John: Maybe I am wrong.</p></blockquote><p>John Wick 4, (2023)</p></blockquote><p>It&rsquo;s been a long overdue to write a post about my past year&rsquo;s Google Summer of Code (GSoC) project. <a href=https://github.com/dart-lang/jnigen>jnigen</a> is an experimental bindings generator which aims to provide Java interoperability for Dart. It works by generating wrappers which call JNI through Dart&rsquo;s FFI (Foreign Function Interface).</p><p>I developed the initial versions of this package under the guidance of Daco Harkes and Liam Appelbe from Dart team. Hossein Yousefi from Dart team is developing the project further, adding many features such as Generics and Kotlin language support.</p><h2 id=why>Why?</h2><p>The current way of accessing platform APIs on Flutter is Method Channels. Channels neatly avoid the intricacies of native language interop, by using an message passing mechanism instead. However, there are a few drawbacks to this:</p><ul><li><p>All calls to method channels have to be asynchronous</p></li><li><p>Sharing memory is not possible.</p></li><li><p>De/serialization of data across the language boundary is relatively expensive.</p></li><li><p>Perhaps more important, currently the use of method channels requires writing quite a bit of boilerplate. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></li></ul><p>Therefore, it&rsquo;s desirable to have an automatic bindings generator for Java libraries, for ergonomics reasons. Using FFI instead of method channels enables better performance and eliminates the need for asynchrony as well.</p><p>Dart already has an excellent bindings generator for C, called <code>ffigen</code>. It was written 2 years ago by Prerak Mann, in 2020 GSoC. It has been later extended to support Objective-C as well. It uses <code>libclang</code> to parse the C headers and generate wrapper code for calling them. The goal of <code>jnigen</code> was to provide similar facility for Java libraries, by combining Dart&rsquo;s FFI and Java Native Interface (JNI).</p><p>We had the prior art of <code>ffigen</code> which simplified several decisions. However there were challenges unique to Java.</p><ul><li>How to parse the Java libraries? In C/C++, libclang is ubiquitous for this purpose.</li><li>In case of C, the <code>ffi</code> library is already provided by the dart. For Java, we had to develop a support library.</li><li>C dependency graphs are fairly sparse, and you can provide some header file paths to the tool. In comparison Java build systems and dependency configurations tend to be complex systems in their own right.</li></ul><p>As a rule of thumb, everything about Java interop (runtime, parsing, build) is less known, or less obvious. As a student, GSoC was my first attempt to write anything with real world scope. Therefore, I learned several practices and principles.</p><p>The aim of this post is to give a glance of various architectural and design decisions, as well as the lessons I learned from this project.</p><p>Before we start, here&rsquo;s a post-facto, approximately-correct architecture diagram which might explain what I am actually trying to build:</p><p><img src=/images/building_jnigen/jnigen_architecture.png alt="An Approximate Architecture Diagram"></p><h2 id=jni-runtime-support>JNI runtime support</h2><p>JNI is an native interface designed with C interop in mind <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Therefore, a number of quirks have to be considered when our goal is to abstract the JNI to a high level language like Dart.</p><h3 id=differences-between-platforms>Differences between platforms</h3><p>On Android, Flutter application runs embedded in Android JVM. Therefore the VM already exists. We just initialize the JNI using a plugin, and also obtain a reference to application context.</p><p>On standalone targets (Flutter Desktop and standalone Dart), there&rsquo;s no JVM. On initialization, a JVM has to be spawned, using the JRE available on the machine. If you intend to use some external libraries, (like the PDFBox library we use in one of the example), the JAR files must be provided as classpath.</p><p>Besides, using <code>jnigen</code> requires support library written in C. It&rsquo;s packaged automatically with Flutter apps since it&rsquo;s a native plugin. However, this library&rsquo;s path must be provided with standalone.</p><p>99% of real world application of Java interop will be on Android. There are enough quirks in standalone support <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> that they outnumber the population of some European countries.</p><p>Then why take the pain to implement support for standalone targets? <strong>Having standalone support enables unit testing of support library & generated bindings.</strong> This feedback loop is invaluable.</p><h3 id=thread-local-this-thread-local-that>Thread-local this, thread-local that</h3><p><code>JNIEnv</code> struct, basically a vtable of 200+ functions, provides the entry point for most functionality of the JNI. Unfortunately this struct is valid only in the thread it is obtained.</p><p>Dart being a high level language, Thread pinning is <a href=https://github.com/dart-lang/sdk/issues/46943>not yet supported</a>, and we didn&rsquo;t want to rely on implementation details of threading, in presence of async-await in the language. Thus the <code>JNIEnv *</code> was wrapped in a <code>thread_local</code>. This singleton design was not really a problem, because there can be at most 1 JVM in a process, anyway.</p><p>For the same reason, all references returned from JNI are converted to global references before returning to Dart. This works fine in practice. Reference lifecycle is handled by <code>NativeFinalizer</code> mechanism, with an API for explicit deletion if required.</p><h3 id=the-curious-case-of-the-ui-thread-classloader>The curious case of the UI thread classloader</h3><p>Android has a concept of UI thread. Confusingly, in a Flutter app, this is different from the thread running Flutter application.</p><p>It turns out, most platform classes are not available if you call JNI&rsquo;s <code>FindClass</code> from a flutter thread. This is because those threads have a much barebones classloader. The solution suggested by <a href=https://developer.android.com/training/articles/perf-jni>Android Developers documentation</a> is to store a reference to original thread&rsquo;s class loader and call its <code>loadClass</code> method instead of JNI&rsquo;s <code>FindClass</code>, which worked for us.</p><h3 id=the-perils-of-dynamic-loading>The perils of dynamic loading</h3><p>The generated C code needs to call the function in C support library. At minimum, it should be able to access the shared context such as the class loader. However, we can&rsquo;t link them in compile time, with existing Flutter build system.</p><p>The other solution is to load the DLLs into a shared namespace. However it was not feasible because on some platforms, <code>DynamicLibrary.open</code> implementation loads symbols into local namespaces of the library, and not expose it. <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. We worked around it by having the initialization code in dart, which set some pointers in generated C code. <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p>After all the workarounds, it was possible to use JNI from the support library <code>package:jni</code>. Although it wasn&rsquo;t most ergonomic thing to use directly, it was supposed to provide a layer shared by all generated wrappers.</p><h3 id=a-glimpse-of-one-off-apis>A glimpse of one-off APIs</h3><p>My litmus test at these stages was being able to call some Android built-in APIs, such as displaying a <code>Toast</code> message, or getting time since boot <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. The latter will be a simple one-liner on Android.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>long</span> millisecondsSinceBoot <span style=color:#f92672>=</span> SystemClock.<span style=color:#a6e22e>uptimeMillis</span>();
</span></span></code></pre></div><p>If you call this using JNI primitives, there will be a number of steps</p><ul><li>Find class <code>SystemClock</code>.</li><li>Find static method <code>uptimeMillis</code> on <code>SystemClock</code>. A fairly cryptic signature also needs to be specified. Here the signature is <code>()J</code> which means this method takes no arguments and returns a <code>long</code>.</li><li>Call this static method and obtain the result.</li><li>Check if there&rsquo;s an exception.</li><li>Return the result to the caller.</li></ul><p>While the ideal way to avoid this is generating wrapper, support library <code>package:jni</code> still provides a way to call methods without generating code. This layer of abstraction is intended for <em>one-off usages and testing</em>. It&rsquo;s still quite verbose but better than calling the methods on <code>JNIEnv</code> directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span>Jni.findJClass(<span style=color:#e6db74>&#34;android/os/SystemClock&#34;</span>).use(
</span></span><span style=display:flex><span>    (systemClock) <span style=color:#f92672>=&gt;</span> systemClock.callStaticMethodByName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;uptimeMillis&#34;</span>, <span style=color:#e6db74>&#34;()J&#34;</span>, [], JniCallType.longType),
</span></span><span style=display:flex><span>  );
</span></span></code></pre></div><p>These are &ldquo;stringy&rdquo; APIs which are only supposed to be for one-off uses where you can&rsquo;t generate code, and debugging. The actual <code>jnigen</code>-generated bindings will use slightly lower level APIs, storing method references etc.. into class fields when appropriate.</p><p><img src=/images/building_jnigen/Dart_JNI_Example_Screenshot.png alt="Screenshot of an Example app Demonstrating various JNI calls"></p><h2 id=parsing-java-libraries>Parsing Java libraries</h2><h3 id=the-problem-we-need-an-ast>The problem: we need an AST</h3><p>To generate bindings, we need to know the API of the library. If we consider a method, we need to know the name of the method, types of arguments and return types. We will also want names of arguments, and ideally the documentation comments to be carried to the target language. Similarly, we need to know what classes and fields are there, what&rsquo;s the superclass of given class, etc.. All of this information will be in hierarchical manner. Sounds familiar right? We need this information as an Abstract Syntax Tree.</p><p>This tree does not need to contain the information down to statement or expression level. However, AST is the closest term to what is required here. This hierarchical API information has to be parsed from some artifact, which is either JAR file, source code or JavaDoc HTML.</p><p>(Modern IDEs do a lot of similar things. For example, IntelliJ IDEA displays the documentation on hover, if you configure it to download JavaDocs or sources.)</p><h3 id=parsing-jars-vs-parsing-the-source>parsing JARs vs parsing the source</h3><p>I first tried parsing the JAR files using the excellent <code>asm</code> library. But soon I stumbled upon the caveat, that compiled JARs do not contain parameter names for methods. <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup></p><p>So I went ahead and created a prototype using <a href=https://github.com/javaparser/javaparser>javaparser</a> library, which can parse the source files, and has a workable symbol resolver. However, later we decided in favor of OpenJDKs <a href=https://openjdk.org/groups/compiler/using-new-doclet.html>doclet API</a>, which has the benefit of being on par with the standard OpenJDK compilers. While the default doclet produces API documentation in HTML format, we can use the API to produce a JSON of API exported by the library, which represents the hierarchical tree structure.</p><p>One drawback of doclet parser is that it requires the Java source code to be well formed. That is, if you have a source file referencing a class <code>Xyz</code>, this <code>Xyz</code> class has to exist somewhere in sources or classpath you provided to this tool. This implies that all compile time dependencies of the class has to be present. It&rsquo;s a significant limitation. There&rsquo;s a plan to support a more tolerant source parser, using QDox / JavaParser / Eclipse ECJ, which will eliminate the requirement of having all dependencies.</p><p>Later, we also added support for parsing JARs using <code>asm</code>. Because it&rsquo;s convenient for cases where we cannot get well-formed sources. Also, Kotlin support which was added later works using this parser.<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup></p><h3 id=why-output-json-and-not-use-jni>Why output JSON and not use JNI?</h3><p>This parser component (called <code>ApiSummarizer</code>) currently runs as a standalone process and outputs JSON. You might ask &ldquo;why does it not use JNI itself&rdquo;? To be honest, we just haven&rsquo;t got time to do the dogfooding exercise.</p><p>Besides, such an implementation will be fairly verbose with the features currently supported by <code>jnigen</code>, since the communication from <code>ApiSummarizer</code> is an one way street with a single JSON blob of &ldquo;plain old data&rdquo; type. When <code>jnigen</code> matures, it might support the plain-old-data types better which will also reduce the effort of such dogfooding.</p><h2 id=generating-code>Generating code</h2><p>Unlike what we expected in the beginning of the project, a significant portion of effort has gone to the support library and parsing, and less to the generated code. Code generation is basically templated string concatenation. The generated code contains functions which call the corresponding C function.</p><p>The initial plan was to have each Java symbol generate a wrapper function in C, and have the Dart wrapper call this C wrapper. In the hindsight, this C function should not even be required because we can factor most calling patterns into few Dart functions, and factor them into the support library&rsquo;s dart interface. I wish this was the path I followed from the beginning. Currently we have both versions of bindings (Pure dart and Dart+C). They&rsquo;re both tested with same test cases.</p><p>The long-term plan is to do some benchmarking and discard C-based bindings. Pure dart bindings have the advantage of not complicating the build system. They can be just built as normal flutter package without any native dependency except the JNI support library. Further, it&rsquo;s only dart code and lends to tree shaking, unlike the C bindings which have to be built as shared library.</p><p>The only disadvantage at the time of implementation was the unavailability of FFI varargs, requiring a native allocation for each call to pass the arguments as an array. Now that FFI varargs are available in Dart, I expect this gap to reduce soon.</p><p>For sake of completeness, here&rsquo;s what our <code>SystemClock.uptimeMillis</code> binding looks like in generated code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> _id_uptimeMillis <span style=color:#f92672>=</span> jni.Jni.accessors
</span></span><span style=display:flex><span>      .getStaticMethodIDOf(_class.reference, <span style=color:#e6db74>r&#34;uptimeMillis&#34;</span>, <span style=color:#e6db74>r&#34;()J&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// from: static public native long uptimeMillis()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> uptimeMillis() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jni.Jni.accessors.callStaticMethodWithArgs(
</span></span><span style=display:flex><span>        _class.reference, _id_uptimeMillis, jni.JniCallType.longType, []).long;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>As you can guess, it can be called as easily as in java - <code>SystemClock.uptimeMillis()</code>.</p><p>Not all calls will be this easy though. Sometimes there will be more boilerplate involved. All Java classes are wrapped as subclass of <code>JObject</code> type, which wraps a JNI global reference. This applies to Java <code>String</code> as well, which gets mapped to <code>JString</code> class in Dart. Therefore, passing Strings to Java methods requires calling <code>.toJString</code> extension method.</p><p>Sometimes it&rsquo;s not possible to generate bindings for a required class, it can be still accessed through reflective APIs. This is a snippet from the examples in <code>jnigen</code> repo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span>  <span style=color:#66d9ef>final</span> inputFile <span style=color:#f92672>=</span> Jni.newInstance(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;java/io/FileInputStream&#34;</span>, <span style=color:#e6db74>&#34;(Ljava/lang/String;)V&#34;</span>, [file]);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> pdDoc <span style=color:#f92672>=</span> PDDocument.load6(inputFile);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> pages <span style=color:#f92672>=</span> pdDoc.getNumberOfPages();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> info <span style=color:#f92672>=</span> pdDoc.getDocumentInformation();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> title <span style=color:#f92672>=</span> info.getTitle();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> subject <span style=color:#f92672>=</span> info.getSubject();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> author <span style=color:#f92672>=</span> info.getAuthor();
</span></span><span style=display:flex><span>  stderr.writeln(<span style=color:#e6db74>&#39;Number of pages: </span><span style=color:#e6db74>$</span>pages<span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>title.isNull) {
</span></span><span style=display:flex><span>    stderr.writeln(<span style=color:#e6db74>&#39;Title: </span><span style=color:#e6db74>${</span>title.toDartString()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>In this, we couldn&rsquo;t generate bindings for <code>FileInputStream</code> class<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>. But it&rsquo;s still possible to use a <code>FileInputStream</code> with the escape-hatch.</p><h2 id=package-manager-integrations>Package manager integrations</h2><p>As previously mentioned, the source code needs to be well formed for parsing. Most Java code in real world, especially Android code, will have bunch of dependencies which are difficult to procure manually. It&rsquo;s desirable to have a way to get these dependencies from <code>maven</code> or <code>gradle</code>.</p><p>Maven has an excellent plugin called <code>Maven dependency plugin</code> which simplifies most of work with maven dependencies. There&rsquo;s some thin code wrapping over this command. It makes getting libraries like <code>pdfbox</code> (which we used in a standalone example) a breeze. You can specify something like this in <code>jnigen.yaml</code> and <code>jnigen</code> will download the JAR / sources from maven. <sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>maven_downloads</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e>## For these dependencies, both source and JARs are downloaded.</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>source_deps</span>:
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#39;org.apache.pdfbox:pdfbox:2.0.26&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>## Runtime dependencies for which bindings aren&#39;t generated directly.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>## Only JARs are downloaded.</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>jar_only_deps</span>:
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#39;org.bouncycastle:bcmail-jdk15on:1.70&#39;</span>
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#39;org.bouncycastle:bcprov-jdk15on:1.70&#39;</span>
</span></span></code></pre></div><p>Similarly, we have a use case of generating bindings to Java files in an Android app project (as opposed to a generic library). These depend on various Platform and AndroidX libraries which cannot be obtained by maven. We currently workaround by running some gradle stubs which print the paths to these JARs on local system. Long term plan is to migrate this logic to a gradle plugin.</p><h2 id=configuration>Configuration</h2><p>My initial plan was to expose <code>jnigen</code> as an API, so that users can write a dart script in <code>tool/</code> directory of the project and call it. However, Daco suggested to provide a YAML configuration similar to what <code>ffigen</code> does. It was indeed a better idea from end-user perspective. (At least, this project is not kubernetes-scale and will never require templated YAML packed in an OCI container image).</p><p>Another nice effect of implementing YAML config is that it steered the design of configuration towards being more <em>declarative</em> and tidy. In my initial design, user would&rsquo;ve to imperatively call the maven utilities described above, using an API. Later, I just made it another configuration parameter, which is much nicer.</p><h2 id=other-stuff>Other stuff</h2><p>Code generation is heavily used even inside the project. One set of tests which test Dart+C bindings are replicated to test pure dart bindings. This can&rsquo;t be abstracted in code because imports will be different, so code generation is the practical option here. Similarly, a script written against <code>ffigen</code>&rsquo;s internal AST representation is used to generate some C wrappers from <code>jni.h</code> of Android NDK.</p><p>CheckJNI on Android has been quite helpful. In the beginning, some functionality was only tested on standalone using unit tests. We wanted to run same unit tests on Android. Since there&rsquo;s no provision in flutter for running Unit tests on another device, we made a stub application which ran these tests using integration test mechanism. This uncovered bugs which didn&rsquo;t occur on standalone target. For instance the spec defines <code>NewGlobalRef</code> can&rsquo;t be called when an exception is pending. However it happened to work on standalone Dart target (which uses OpenJDK using the JNI invocation API), and the bug was found when the same test was run on Android.</p><p>Performance on small tests seems good so far. On a synthetic benchmark which mainly measured trivial calls, we can see more than 10x average improvement over method channels. In practice, if you call into Java, Java code needs to justify it by doing some heavy-lifting anyway. So I believe the main value of the code-generation interop is ergonomics, and then performance.</p><p><img src=/images/building_jnigen/rudimentary_benchmarks.png alt="Some rudimentary benchmarks measuring the overhead against platform channels"></p><h2 id=future-work>Future work</h2><p>I have to admit that I underestimated the complexity of this project. It&rsquo;s usable in current state (at the time of writing this), but there&rsquo;s lot of work to be done. Having almost no prior experience with real world programming, I am perplexed at the architectural detail it took to get the smallest things working.</p><p>After last December, I became busy with other stuff including college work, and only contributed to the project intermittently. During this time, Hossein from Dart team took up the project. He has developed some amazing features such as Generics, special support for common types (List, Set), and Kotlin support (including suspend functions).</p><h3 id=language-features>Language features</h3><p><em>Callbacks into Dart</em> is the most obvious missing feature. It&rsquo;s not straightforward to do this generically with JNI. The current plan is to use Proxy classes.</p><p>Generics, exceptions and inheritance implementations are very barebones, and need to support more Java features. For example, all exceptions in Java are thrown as <code>JniException</code>, which makes it difficult to handle different exceptions in <code>catch</code> clauses of Dart code.</p><p>Kotlin support is another thing. Kotlin and Dart are both languages with a chocolate shop of syntactic and type system features, and interop with Kotlin will be more sophisticated than just Java interop.</p><h3 id=obtaining-sources-and-parsing>Obtaining sources and parsing</h3><p>Gradle integration as it exists today is a hack. It has to write a stub <code>build.gradle</code> file, run it and collect the paths of dependency JARs. The proper way to do it is using gradle plugins.</p><p>Requiring well-formed sources is another pain point. We would ideally have another more tolerant parser for partial sources, which would gracefully degrade when a symbol encountered in source is undefined. The plan is to implement such an option using an open source parsing library, or alter one (Starting from a grammar is impractical.)</p><h3 id=performance>Performance</h3><p>Currently, overhead of JNI call appears to be around 10% of the Flutter method channels, from some basic benchmarking. More rigorous benchmarking is needed, of course.</p><p>It could be optimized further, but it wouldn&rsquo;t be a very productive endaveour to microbenchmark extensively - because real world usage patterns vary between platform channels and code-generation based interop.</p><ul><li><p>If you&rsquo;re calling Java code, it has to be doing some heavy lifting, like calling some system APIs which cost more than the overhead of method call itself.</p></li><li><p>The difficulty of writing method channel code may force to keep the interface small with very few methods, which will usually have a positive impact on performance.</p></li><li><p>With channels, you can probably squeeze a little more performance by using <code>BinaryCodec</code> and writing tight ser/de code.</p></li></ul><p>It&rsquo;s always (whether using channels or JNI) a good practice to keep the interface between languages small.</p><p>The niche performance opportunity with having JNI as interop layer instead of serialization is sharing native memory through <code>DirectByteBuffer</code>. It would be nice to have an API similar to <code>typed_data</code> which facilitates sharing memory.</p><h3 id=better-support-for-plain-old-data-types>Better support for &ldquo;Plain Old Data&rdquo; types</h3><p>Some classes are just structured containers for data. The current <code>jnigen</code> translation scheme assumes every class has behavior, and fields are accessed individually. But sometimes, it&rsquo;s better to treat an object as a container of structured data, and eagerly convert all fields into Dart types.</p><p>To give an example, suppose we have a class called name. For brevity, let&rsquo;s ignore all getter / setter conventions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>  String firstName;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Nullable</span> String middleName;
</span></span><span style=display:flex><span>  String lastName;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>JNIgen will wrap this into a Dart class, containing a reference to original object and accessing String fields through JNI when they are required. Further, any field of non-primitive type (including String), will return a wrapper object referring to a Java object.</p><p>But when all of this is a heap of data, and if we never pass anything from this back into Java code, then it&rsquo;s better to convert the entire structure into a dart class at one go, and discard any references into Java.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// dart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>String</span> firstName, lastName;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>String</span><span style=color:#f92672>?</span> middleName;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The <del>pedantic</del> observant reader would point out that it&rsquo;s just deserialization in disguise.</p><p>It will be certainly interesting to see whether binary-deserializing the entire thing into a byte buffer, and deserializing it back from Dart will be more efficient than populating the target POD structure field-by-field. Either way, the primary value in such conversion is ergonomics (getting a dart POD type without any effort) and not performance minutiae.</p><h2 id=lessons-learned>Lessons learned</h2><p><code>jnigen</code> was my first project with real world scope. I personally learned few valuable things about software engineering in general.</p><h3 id=aggressive-automation>Aggressive Automation</h3><p>The basic principle of our profession is that computer can do repetitive things much, much better than we can. Whenever there&rsquo;s a repetitive task, I was adviced to create a script for that rather than documenting the commands for that.</p><p>Sometimes it appears automating something is not worth it because initial automation effort exceeds the (apparent) time saved. That sentiment, however, neglects the reproducibility benefit of scripting something.</p><p>Something can take 30 second and may appear &ldquo;not worth scripting&rdquo; when you have full context of the code. However, the 30 second may become 10 minutes once you lose context, or someone else has to perform the same sequence of 5 commands. I have come to firmly believe reproducibility and knowledge transfer effects of automating things are worth more than the initial time investment in most cases.</p><h3 id=testing>Testing</h3><p>Perhaps due to the disconnect from real world software engineering, most students are never taught how to test, and the importance of correct testing. The main purpose of having automated tests is not finding bugs - <strong>it&rsquo;s about making changes peacefully without the fear of breaking something somewhere</strong>. From that perspective, writing automated tests is mostly about velocity more than correctness.</p><p>Another lesson was that tests are also code, and thus have to be abstracted properly. In practice I always found myself writing a <code>test_util</code> directory. Often, many tests follow same pattern and we can just vary the parameters. One great thing about Dart&rsquo;s testing libary compared to JUnit / TestNG etc.. is that a test is registered with single function call, which makes it less awkward to abstract away various patterns than with classes and annotations etc..</p><p>I also learned some discipline with testing. Initially I had written too many end-to-end testing, and not many unit tests. As time passed, they took too much time to run.</p><h3 id=well-architected-is-half-done>Well architected is half done</h3><p>While its impossible to achive a perfect architecture, there are many things in <code>jnigen</code> which, had I architected them better, would&rsquo;ve saved much time down the line.</p><p>I have learned the sense of good design, apart from intuition, requires a broad knowledge - including the understanding of how things are done in various other software.</p><p>One small example is the command line option overrides. I implemented the overrides mechanism similar to system properties in various Java applications, (<code>-Dproperty.name=value</code>), with list values being delimited by <code>;</code>. This would help to change the properties for single invocation of the tool, which has been found quite useful.</p><p>If I were to implement it today, I would consider arbitrary JSON overrides rather than splitting by <code>:</code> - which would&rsquo;ve been more elegant and support more complex values. This realization occurred when I saw the override mechanism in <code>helm</code>.</p><p>Another small example: in tests, we generate and compare bindings with a set of reference bindings. Instead of using string comparison, we found its a good idea to invoke <code>git diff --no-index</code>, which gives a better line-by-line diff.</p><p>Similarly, keeping logs as files was inspired by CMake and <code>kdesrc-build</code>.</p><h2 id=conclusion>Conclusion</h2><p>I am optimistic that <code>jnigen</code> will be versatile Java (and Kotlin) interop toolkit for Dart one day. If it doesn&rsquo;t, we will have enough lessons that might help someone implementing JNI interop for some other language.</p><p>Personally, participating in this project has been a skill upgrade for me. It was an architectural and implementation challenge, and I had so much lessons to learn.</p><p>I&rsquo;d like to thank the Dart team members, especially Daco, Liam and Hossein, for their guidance in the project. I&rsquo;d also thank the GSoC program for giving a chance to me, someone with no other interesting programming background, to get involved.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><code>pigeon</code> does a bit to alleviate this, but still requires the developer to specify the interface and implement it in platform language. Tools like <code>ffigen</code> and <code>jnigen</code> approach it from different direction, by binding to whatever interface is exposed by the library.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>currently a <a href=https://openjdk.org/jeps/424>newer interface</a> is implemented as part of Project Panama, but it won&rsquo;t be on Android anytime soon.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>One of such surprises is that, on Windows, you have to link the JVM libraries using <code>DELAYLOAD</code> linker flags, or else it fails to load with a generic error code. It reminds me of <code>No such file or directory</code> error in Linux, which can in fact happen due to a missing library.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>The default behavior appears to differ across platforms. Windows and MacOS use global symbol namespace (<code>RTLD_GLOBAL</code> or equivalent), whereas Android and glibc use per-library namespace (<code>RTLD_LOCAL</code>). The <code>DynamicLibrary.open</code> in Dart FFI doesn&rsquo;t have a way to change this, since it&rsquo;s cross platform.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>This is one of the reasons I have been bullish on pure dart bindings, which should&rsquo;ve been obvious in the hindsight.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>I believe these are more illustrative than calling an integer / double function. These examples already involved solving the class loader problem and figuring out a way to get application context on Android.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Actually it can, if you pass <code>-parameters</code> to the compiler. But it&rsquo;s very inconvenient to recompile a binary library.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>We are considering parsing Kotlin sources through a documentation engine such as Dokka, or even parsing the JavaDoc directly.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>It&rsquo;s certainly possible to bind to standard library classes. In this standalone example however, we couldn&rsquo;t do this without adding a system-dependent path to config. <a href=https://github.com/dart-lang/jnigen/tree/main/jnigen/example/in_app_java>in_app_java</a> example in jnigen repo shows an example without much extra configuration. With some circus around module layout, it&rsquo;s also possible to use Android SDK 28 sources, which are well-formed. Here&rsquo;s <a href=https://github.com/mahesh-hegde/java_jni_sample>an example</a>.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>An observant reader will see that Bouncy Castle dependencies are specified explicitly. These aren&rsquo;t hard dependencies of PDFBox but required transitively by most of the Java code we parse.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></div><div class=prev-next></div></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><a href=#why>Why?</a></li><li><a href=#jni-runtime-support>JNI runtime support</a><ul><li><a href=#differences-between-platforms>Differences between platforms</a></li><li><a href=#thread-local-this-thread-local-that>Thread-local this, thread-local that</a></li><li><a href=#the-curious-case-of-the-ui-thread-classloader>The curious case of the UI thread classloader</a></li><li><a href=#the-perils-of-dynamic-loading>The perils of dynamic loading</a></li><li><a href=#a-glimpse-of-one-off-apis>A glimpse of one-off APIs</a></li></ul></li><li><a href=#parsing-java-libraries>Parsing Java libraries</a><ul><li><a href=#the-problem-we-need-an-ast>The problem: we need an AST</a></li><li><a href=#parsing-jars-vs-parsing-the-source>parsing JARs vs parsing the source</a></li><li><a href=#why-output-json-and-not-use-jni>Why output JSON and not use JNI?</a></li></ul></li><li><a href=#generating-code>Generating code</a></li><li><a href=#package-manager-integrations>Package manager integrations</a></li><li><a href=#configuration>Configuration</a></li><li><a href=#other-stuff>Other stuff</a></li><li><a href=#future-work>Future work</a><ul><li><a href=#language-features>Language features</a></li><li><a href=#obtaining-sources-and-parsing>Obtaining sources and parsing</a></li><li><a href=#performance>Performance</a></li><li><a href=#better-support-for-plain-old-data-types>Better support for &ldquo;Plain Old Data&rdquo; types</a></li></ul></li><li><a href=#lessons-learned>Lessons learned</a><ul><li><a href=#aggressive-automation>Aggressive Automation</a></li><li><a href=#testing>Testing</a></li><li><a href=#well-architected-is-half-done>Well architected is half done</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2025 Mahesh Hegde</span>
<span>Blog using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a> theme.</span></footer></body></html>