<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>A tale of Interface Smuggling in Go net/http</title>
<meta name=description content><meta name=keywords content='Go,HTTP,Debugging'><meta property="og:url" content="https://mahesh-hegde.github.io/posts/go-interface-smuggling/"><meta property="og:type" content="website"><meta property="og:title" content="A tale of Interface Smuggling in Go net/http"><meta property="og:description" content><meta property="og:image" content="https://mahesh-hegde.github.io/"><meta property="og:image:secure_url" content="https://mahesh-hegde.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="A tale of Interface Smuggling in Go net/http"><meta name=twitter:description content><meta property="twitter:domain" content="https://mahesh-hegde.github.io/posts/go-interface-smuggling/"><meta property="twitter:url" content="https://mahesh-hegde.github.io/posts/go-interface-smuggling/"><meta name=twitter:image content="https://mahesh-hegde.github.io/"><link rel=canonical href=https://mahesh-hegde.github.io/posts/go-interface-smuggling/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fbe2f55794ed6ded1573152a130784ee5cb022de9676b19dd37d7559ee6f6fc6.js integrity="sha256-++L1V5Ttbe0VcxUqEweE7lywIt6WdrGd0311We5vb8Y="></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=nav-title><a class=nav-brand href=https://mahesh-hegde.github.io/>Mahesh's Blog</a></div><div class=nav-links><div class=nav-link><a href=https://mahesh-hegde.github.io/posts/>Posts</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/tags/>Tags</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/cv/>CV</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/readings/>Readings</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/about/>About</a></div><div class=nav-link><a href=mailto:net.mahesh29@gmail.com><span data-feather=mail></span></a></div><div class=nav-link><a href=https://github.com/mahesh-hegde><span data-feather=github></span></a></div><div class=nav-link><a href=https://www.linkedin.com/in/mahesh-bhaskar-hegde/><span data-feather=linkedin></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span id=dark-theme-toggle-screen-reader-target class=sr-only></span>
<a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span id=hamburger-menu-toggle-screen-reader-target class=sr-only>menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://mahesh-hegde.github.io/posts/>Posts</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/tags/>Tags</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/cv/>CV</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/readings/>Readings</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/about/>About</a></li><li class=nav-item><a href=mailto:net.mahesh29@gmail.com><span data-feather=mail></span></a></li><li class=nav-item><a href=https://github.com/mahesh-hegde><span data-feather=github></span></a></li><li class=nav-item><a href=https://www.linkedin.com/in/mahesh-bhaskar-hegde/><span data-feather=linkedin></span></a></li><li class="nav-item dark-theme-toggle"><span id=dark-theme-toggle-screen-reader-target class=sr-only>theme</span>
<a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>A tale of Interface Smuggling in Go net/http</h1><small role=doc-subtitle></small><p class=post-date>March 1, 2024</p><ul class=post-tags><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/go>Go</a></li><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/http>HTTP</a></li><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/debugging>Debugging</a></li></ul></div><div class=post-content><p><h2 id=the-humble-beginnings>The humble beginnings</h2><p>Once upon a time, I had a use case for serving the contents inside of a zip file over HTTP, preferably without unpacking the <code>.zip</code> to a temporary directory.</p><p>Go is a language made for writing HTTP servers. Since we can represent zip file as a filesystem <code>fs.FS</code>, how hard would it be to write a file server to serve files from it?</p><p>Well, it was harder than I thought.</p><p>For sake of this demonstration, let&rsquo;s create a zip file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed vel velit non ipsum condimentum ornare. Sed quis tellus facilisis, rhoncus purus eget, dapibus libero. Sed sed diam semper, malesuada turpis non, vestibulum urna. Quisque et consequat libero. Vestibulum tempor elementum diam, a consectetur risus hendrerit sed.&#34;</span> &gt; sample_text
</span></span><span style=display:flex><span>zip -r sample.zip sample_text
</span></span></code></pre></div><p>Now this is very straightforward Go code - to open a zip file, wrap it in <code>http.FileSystem</code> and attach the handler to HTTP server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;archive/zip&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zipPath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zipFile</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>zipPath</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zipFileStat</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>zipFile</span>.<span style=color:#a6e22e>Stat</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zipReader</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>zip</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>zipFile</span>, <span style=color:#a6e22e>zipFileStat</span>.<span style=color:#a6e22e>Size</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fileserver</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>FileServer</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>FS</span>(<span style=color:#a6e22e>zipReader</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v [%s] %v: %v\n&#34;</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>RemoteAddr</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Method</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>RequestURI</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fileserver</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Listening on http://127.0.0.1:8080&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;127.0.0.1:8080&#34;</span>, <span style=color:#a6e22e>mux</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pretty straightforward. Now let&rsquo;s try it.</p><pre tabindex=0><code>[~/Code/zip-server] $ go run main.go sample.zip
2024/03/01 21:14:24 Listening on http://127.0.0.1:8080
# On other terminal
[~/Code/zip-server] $ curl http://localhost:8080/sample_text
seeker can&#39;t seek
</code></pre><p>What nonsense?</p><p>Upon reading the error message, we get a clue - that HTTP server is trying to seek inside the files we are providing - which are not real files but entries inside zip files. Since these are compressed, they are not seekable.</p><p>However, it&rsquo;s said nowhere in the interface signatures that the files need to be seekable, we are providing <code>fs.FS</code>, and <code>Open()</code> on an <code>FS</code> will return <code>fs.File</code>, which is only required to implement <code>Read</code>, <code>Stat</code> and <code>Close</code>.</p><p>Digging around a bit, it&rsquo;s possible to find the <a href=https://pkg.go.dev/net/http#FS>documentation</a> which says filesystem provided to <code>http.FS</code> must return seekable files. (However it doesn&rsquo;t explain why).</p><p>Now I&rsquo;m curious, why? (After all, I am just linearly downloading files, I am not making any HTTP range requests.)</p><pre tabindex=0><code>[~/.local/go/src] $ grep -rn &#34;seeker can&#39;t seek&#34;
net/http/fs.go:213:var errSeeker = errors.New(&#34;seeker can&#39;t seek&#34;)
net/http/fs.go:245:                             Error(w, &#34;seeker can&#39;t seek&#34;, StatusInternalServerError)
</code></pre><p>Clicking around, I find <code>serveFile</code> and <code>ServeContent</code>. Using the VSCode debugger, I find out it&rsquo;s actually <code>serveFile</code> which is called during our <code>fileserver.ServeHTTP(w, req)</code> call.</p><p><img src=/images/go-interface-smuggling/servefile-debug.png alt="ServeHTTP in VSCode debugger"></p><p><code>serveFile</code> in turn calls <code>serveContent</code>, where the seek-back happens after calling <code>DetectContentType</code>. This <code>DetectContentType</code> is called when the file type can&rsquo;t be determined using file extension. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>Now I am tired of clicking around, back to the stone age tools. Since <code>fs.File</code> does not implement seeker, someone&rsquo;s gotta be casting it to <code>io.Seeker</code> or a related type. It&rsquo;s probably the <code>http.FS</code> because it&rsquo;s returning us the filesystem.</p><p>I am tired of clicking around anyway, and more than that, perhaps, fascinated by the stone age tools. Using <code>grep</code> again:</p><pre tabindex=0><code>[~/.local/go/src] $ grep -rn &#39;io.Seeker)&#39;
archive/tar/reader.go:861:      if sr, ok := r.(io.Seeker); ok &amp;&amp; n &gt; 1 {
net/http/fs.go:793:     s, ok := f.file.(io.Seeker)
embed/internal/embedtest/embed_test.go:213:     seeker := file.(io.Seeker)
internal/zstd/zstd.go:316:      if seeker, ok := r.r.(io.Seeker); ok {
</code></pre><p>And here we go, in <code>net/http/fs.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>ioFile</span>) <span style=color:#a6e22e>Seek</span>(<span style=color:#a6e22e>offset</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>whence</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int64</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>file</span>.(<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Seeker</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>errMissingSeek</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Seek</span>(<span style=color:#a6e22e>offset</span>, <span style=color:#a6e22e>whence</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ioFile</code> is the file type returned by <code>ioFS</code>, which is the wrapper type returned by <code>http.FS</code> as an implementer of <code>http.FileSystem</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>FS</span>(<span style=color:#a6e22e>fsys</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>FS</span>) <span style=color:#a6e22e>FileSystem</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ioFS</span>{<span style=color:#a6e22e>fsys</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>TL;DR - <code>http.FS(fsys fs.FS)</code> expects <code>fs.File</code> objects returned by our &ldquo;virtual&rdquo; filesystem <code>fsys</code>, to implement <code>io.Seeker</code>, which is not the part of <code>fs.File</code> interface contract.</strong></p><p><img src=/images/go-interface-smuggling/ragnar-lothbrok-not-original-agreement.png alt="That is not part of our original agreement"></p><h2 id=interlude>Interlude</h2><p>This pattern, where the library is casting a more general interface into a more specific type, is called <a href=https://utcc.utoronto.ca/~cks/space/blog/programming/GoInterfaceSmuggling>Interface Smuggling</a>.</p><p>It&rsquo;s done extensively in Go&rsquo;s standard library, often to give a performance boost to generic operations in frequent cases, without breaking the abstractions. Here&rsquo;s a line of documentation for <code>io.WriteString</code>.</p><pre tabindex=0><code>func WriteString(w Writer, s string) (n int, err error)
    WriteString writes the contents of the string s to w, which accepts a slice
    of bytes. If w implements StringWriter, its WriteString method is invoked
    directly. Otherwise, w.Write is called exactly once.
</code></pre><p>This is because the WriteString may be implemented more efficiently in <code>StringWriter</code>, compared to the standard way of converting string to bytes and writing it. For instance, a <code>strings.Builder</code> may just store a reference to the string instead of converting it to bytes.</p><p>This type of interface smuggling does not usually break the results of the code. But what we encountered here is more severe - the expectation of files being seekable is not communicated in the type system.</p><p>Anyway, coming back to the problem..</p><h2 id=the-solution>The solution</h2><p>Now all we have to do is fake a seek method in zip entries (we don&rsquo;t have a vocabulary for that in Go (unlike Java which calls them <code>ZipEntry</code>), since <code>zip.Reader</code> returns plain generic <code>fs.File</code>).</p><p>There are two ways to fake a seek method on a non-seekable, virtual file. One is easy - just load the entire file into memory, and return a bytes.Reader which is already given by the stdlib. This works reasonably well.</p><p>You would not want to read this much code in nested markdown blocks, so <a href=https://github.com/mahesh-hegde/zserv/blob/main/zip_reader.go>here</a> is a link to full implementation on github, along with some &ldquo;tests&rdquo;.</p><p>The other way is to look at the implementation of <code>'net/http'</code>, and implement just enough <code>Seek</code> behavior, leaving the rest of it undefined.</p><p>If we look at <code>ServeContent</code>, all it tries is seeking to start and to end. I implemented a proxy <code>ReadSeeker</code> which can pretend to do that. We can also observe in the code that it can read at most <code>sniffLen</code> bytes from the beginning, which is defined as 512 bytes. I just added a small buffer to my implementation which stored first 1024 bytes, making the seek possible. Seek to end will just return the size of the Zip entry.</p><p>The code for this is here: <a href=https://github.com/mahesh-hegde/zserv/blob/main/streaming_zip_reader.go>streaming_zip_reader.go</a>. I will just paste the interesting part:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StreamingZipEntryReader</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>File</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Reader</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>StreamingZipEntryReader</span>) <span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>buffer</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Reader</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>File</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>buffer</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Reader</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>buffer</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>StreamingZipEntryReader</span>) <span style=color:#a6e22e>Seek</span>(<span style=color:#a6e22e>offset</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>whence</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int64</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>whence</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>SeekStart</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>offset</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Reader</span>.<span style=color:#a6e22e>Seek</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>SeekStart</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>whence</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>SeekEnd</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>offset</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>stat</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>File</span>.<span style=color:#a6e22e>Stat</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>stat</span>.<span style=color:#a6e22e>Size</span>(), <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;unsupported seek parameters&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Both implementations seem to perform well when zip contains small HTML / PNG files.</p><p>However, when I tested with a zip file containing 1 GiB entry, the streaming version obviously performed much better, both in terms of speed and maximum resident set size (i.e peak memory usage).</p><p><img src=/images/go-interface-smuggling/stats_zserv.png alt="some measurements (and some shell scripting stunts)"></p><h2 id=appendix--miscellaneous>Appendix / Miscellaneous</h2><p>I used the filename <code>sample_txt</code> because if we named it <code>sample.txt</code>, the operation for Detecting MIME type would&rsquo;ve never beeen triggered.</p><p>This was around an year and half ago. Since then, I made a small tool out of this code, and named it <a href=https://github.com/mahesh-hegde/zserv><code>zserv</code></a>, in the proud tradition of hard-to-pronounce and short unix tool names.</p><p>There has also <a href=https://github.com/golang/go/issues/61791>been</a> <a href=https://github.com/golang/go/issues/61791>some</a> <a href=https://github.com/golang/go/issues/42173>discussion</a> on this behavior of <code>net/http</code> in the Go issue tracker.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>(Interestingly there&rsquo;s also <code>ServeContent</code> (public method), which takes a <code>io.ReadSeeker</code> uses a &ldquo;seek-to-end&rdquo; operation to determine file size, to set in <code>Content-Length</code>. Since we have an <code>fs.File</code> in this case, which supports <code>stat</code>, this is not necessary.)&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></div><div class=prev-next></div></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><a href=#the-humble-beginnings>The humble beginnings</a></li><li><a href=#interlude>Interlude</a></li><li><a href=#the-solution>The solution</a></li><li><a href=#appendix--miscellaneous>Appendix / Miscellaneous</a></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2024 Mahesh Hegde</span>
<span>Blog using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a> theme.</span></footer></body></html>