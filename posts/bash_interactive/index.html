<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>Some tricks for Bash shell interactive usage</title><meta name=description content><meta name=keywords content='Bash,Linux'><meta property="og:url" content="https://mahesh-hegde.github.io/posts/bash_interactive/"><meta property="og:type" content="website"><meta property="og:title" content="Some tricks for Bash shell interactive usage"><meta property="og:description" content><meta property="og:image" content="https://mahesh-hegde.github.io/"><meta property="og:image:secure_url" content="https://mahesh-hegde.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Some tricks for Bash shell interactive usage"><meta name=twitter:description content><meta property="twitter:domain" content="https://mahesh-hegde.github.io/posts/bash_interactive/"><meta property="twitter:url" content="https://mahesh-hegde.github.io/posts/bash_interactive/"><meta name=twitter:image content="https://mahesh-hegde.github.io/"><link rel=canonical href=https://mahesh-hegde.github.io/posts/bash_interactive/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.a36f1b6a4f5febef42d44c3508b4dc493d11997d01f0359f4df1cde77aac8cc5.js integrity="sha256-o28bak9f6+9C1Ew1CLTcST0RmX0B8DWfTfHN53qsjMU="></script></head><body><script type=text/javascript>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=nav-title><a class=nav-brand href=https://mahesh-hegde.github.io/>Loop Invariant</a></div><div class=nav-links><div class=nav-link><a href=https://mahesh-hegde.github.io/posts/><span data-feather=book-open></span> Posts</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/tags/><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/cv/><span data-feather=briefcase></span> CV</a></div><div class=nav-link><a href=https://mahesh-hegde.github.io/readings/><span data-feather=book></span> Readings</a></div><div class=nav-link><a href=mailto:net.mahesh29@gmail.com><span data-feather=mail></span></a></div><div class=nav-link><a href=https://github.com/mahesh-hegde><span data-feather=github></span></a></div><div class=nav-link><a href=https://www.linkedin.com/in/mahesh-bhaskar-hegde/><span data-feather=linkedin></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span id=dark-theme-toggle-screen-reader-target class=sr-only></span>
<a><span id=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span id=hamburger-menu-toggle-screen-reader-target class=sr-only>menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://mahesh-hegde.github.io/posts/><span data-feather=book-open></span> Posts</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/cv/><span data-feather=briefcase></span> CV</a></li><li class=nav-item><a href=https://mahesh-hegde.github.io/readings/><span data-feather=book></span> Readings</a></li><li class=nav-item><a href=mailto:net.mahesh29@gmail.com><span data-feather=mail></span></a></li><li class=nav-item><a href=https://github.com/mahesh-hegde><span data-feather=github></span></a></li><li class=nav-item><a href=https://www.linkedin.com/in/mahesh-bhaskar-hegde/><span data-feather=linkedin></span></a></li><li class="nav-item dark-theme-toggle"><span id=dark-theme-toggle-screen-reader-target class=sr-only>theme</span>
<a><span id=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Some tricks for Bash shell interactive usage</h1><small role=doc-subtitle></small><p class=post-date>June 21, 2025</p><ul class=post-tags><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/bash>Bash</a></li><li class=post-tag><a href=https://mahesh-hegde.github.io/tags/linux>Linux</a></li></ul></div><div class=post-content><p><p>While I am not a strict command line affectionado, I have found myself to spend significant time in the terminal, especially when doing devops-y work. Here are some things I learned which will improve the speed when working in terminal.</p><p>Note that many of the snippets here were found by me / edited long back. I may not be able to attribute the correct source of each snippet. Let me know if you know the original sources of any snippets posted herein.</p><h2 id=showing-non-zero-exit-codes-in-red>Showing non-zero exit codes in red.</h2><p>When a command has too little or too less output, it&rsquo;s impossible to visually distinguish whether the command failed or passed. I find it useful to print the exit code in red if it&rsquo;s non-zero. That way a failing command is visually distinct.</p><p>Here&rsquo;s how to set it up in <code>~/.bashrc</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>## Make prompt display error code</span>
</span></span><span style=display:flex><span>prompt_show_ec <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span> <span style=color:#75715e># Catch exit code</span>
</span></span><span style=display:flex><span> ec<span style=color:#f92672>=</span>$?
</span></span><span style=display:flex><span> <span style=color:#75715e># Display exit code in red text unless zero</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $ec -ne <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>;<span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  echo -e <span style=color:#e6db74>&#34;\033[31m[</span>$ec<span style=color:#e6db74>]\033[0m&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>PROMPT_COMMAND<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;prompt_show_ec; </span>$PROMPT_COMMAND<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>And here for zsh.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>precmd_print_cmdres<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    __CMDRES<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$?<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> <span style=color:#e6db74>&#34;</span>$__CMDRES<span style=color:#e6db74>&#34;</span> -ne <span style=color:#ae81ff>0</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        echo -e <span style=color:#e6db74>&#34;\e[31m[</span>$__CMDRES<span style=color:#e6db74>]\e[0m&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>precmd_functions<span style=color:#f92672>+=(</span> precmd_get_kube <span style=color:#f92672>)</span>
</span></span></code></pre></div><p>A failing command would look like this.</p><p><img src=/images/bash_interactive/fail_with_status.png alt="command failing"></p><h2 id=completions-and-fzf>Completions and <code>fzf</code></h2><p>These days most utilities come with tab completion which saves a lot of keystrokes when used correctly.</p><p>I almost never type full filenames. Rather, I can press 2-3 characters and press tab to see if there&rsquo;s a completion (and there usually is).</p><p>Most common Go and Python CLIs come with completion scripts, since it&rsquo;s built into CLI frameworks such as <code>click</code> (Python) and <code>spf13/cobra</code> (Go). Usually they will have a command which will generate the completion script. For example here&rsquo;s <code>kubectl</code>.</p><pre tabindex=0><code>kubectl completion bash &gt; ~/.local/bash_scripts/kubectl_completions
## Source the file ~/.local/bash_scripts/kubectl_completions from ~/.bashrc
</code></pre><p>This combined with <code>fzf</code> I almost never have to type full filenames in the terminal.</p><p><code>fzf</code> provides two things:</p><ul><li>a file chooser which lets you press <code>Ctrl+T</code> and select files from the current folder (recursively).</li><li>A history search which lets you press <code>Ctrl+R</code> and do a fuzzy search among commands in history.</li></ul><p><a href="https://github.com/junegunn/fzf?tab=readme-ov-file#setting-up-shell-integration">FZF Documentation</a></p><h2 id=using-bash-readline-keybindings>Using Bash readline keybindings</h2><p>Often we hold the backspace key or left arrow for tremendous amount of time to edit the bash commands in the terminal. But bash has its own key-bindings. However, this is very different from GUI editors. (partly because this system predates the CUA shortcut system used by most common GUI editors, and partly because there&rsquo;s no reliable way to pass shift key to the terminal application.)</p><p>This system of keybindings is called <code>readline</code> (since its powered by GNU readline library or its equivalents).</p><p>Here are the most common shortcuts I use:</p><pre tabindex=0><code>Ctrl+A: go to beginning of the line
Ctrl+E: go to the end of the line
Ctrl+W: Delete the word left to the cursor
Esc+D: Delete the word on right of the cursor
Ctrl+U: Delete text until beginning of the line
Ctrl+Shift+-: Undo last edit
</code></pre><p>Specifically, the undo feature is very helpful when one needs to remove a large copy pasted string from the terminal.</p><p>Readline has many more keybindings. A manual page <code>man 3 readline</code> should be available on most Linux systems.</p><h2 id=using-an-editor-with-ctrlx-ctrle>Using an editor with <code>Ctrl+X, Ctrl+E</code></h2><p>Often commands are very long and editing them with bare terminal is not convenient.</p><p>For those cases, it&rsquo;s possible to set a GUI editor (or vim on SSH sessions) as <code>EDITOR</code> and use this peculiar keybinding <code>Ctrl+X, Ctrl+E</code> to open the current command in editor. Once the editor is closed, the full edited version of the command will be available on the shell.</p><p>It works the same way <code>git commit</code> uses the editor for editing commit messages - by creating a temp file and reading it back after the editor command exists.</p><p>For using VSCode as editor, I set (in bashrc or similar):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export EDITOR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;code --wait --new-window&#34;</span>
</span></span></code></pre></div><p>the <code>--wait</code> is required otherwise VSCode will detach the process, leading bash to immediately read the temporary file and conclude that there are no edits.</p><p>For <code>zsh</code> some trickery is required to achieve the same.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>export VISUAL<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;code --new-window --wait&#34;</span>
</span></span><span style=display:flex><span>autoload -z edit-command-line
</span></span><span style=display:flex><span>zle -N edit-command-line
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#34;^X^E&#34;</span> edit-command-line
</span></span></code></pre></div><p>Source: <a href=https://unix.stackexchange.com/a/34251>Stack overflow</a></p><h2 id=extend-the-bash-prompt-to-show-peristent-information-such-as-git-and-kubectl-status>Extend the bash prompt to show peristent information such as git and kubectl status</h2><p>Augmenting the default bash prompt (which shows hostname and current directory) with a display of current git repository status is very useful, it serves as a visual reminder / confirmation of the number of new, staged or deleted. So common mistakes like forgetting to add a file before commit can be ignored. And oftentimes it saves the trouble of running <code>git status</code> when the verbose output of the latter is not required.</p><p>As I am writing this, this is what the prompt looks like (this is a blog deployed using github pages)</p><p><img src=/images/bash_interactive/git_prompt.png alt="git prompt"></p><p>It means there are 3 new files and 1 modified file. If I stage a file, it changes to:
<img src=/images/bash_interactive/git_prompt_after_staging.png alt="git prompt after staging"></p><p>When I worked on windows using powershell, I found <code>posh-git</code> prompt very useful. It was more detailed than any alternative (such as git&rsquo;s built-in prompt, or bash-git-prompt). So I <a href=https://github.com/mahesh-hegde/promptsynth>hacked together</a> in some 100s of lines of C code using <code>libgit2</code> a simple, portable version of the git prompt, which I can run on any shell.</p><p>Similarly it&rsquo;s possible to extend the prompt for other persistent contexts one might keep switching between. For kubernetes I find it useful to append <code>kubernetes-context | kubernetes-namespace</code> to the prompt by customizing the <code>PS1</code> variable.</p></p></div><div class=prev-next></div></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><a href=#showing-non-zero-exit-codes-in-red>Showing non-zero exit codes in red.</a></li><li><a href=#completions-and-fzf>Completions and <code>fzf</code></a></li><li><a href=#using-bash-readline-keybindings>Using Bash readline keybindings</a></li><li><a href=#using-an-editor-with-ctrlx-ctrle>Using an editor with <code>Ctrl+X, Ctrl+E</code></a></li><li><a href=#extend-the-bash-prompt-to-show-peristent-information-such-as-git-and-kubectl-status>Extend the bash prompt to show peristent information such as git and kubectl status</a></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2025 Mahesh Hegde</span>
<span>Blog using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a> theme.</span></footer></body></html>